# Про типы и интерфейсы

## Используйте то, что лучше подходит по смыслу

**Типы** больше относятся к **данным**. Они, с одной стороны, определяют множество допустимых значений, которые могут принимать данные какого-либо типа, а с другой стороны определяют набор допустимых операций над данными какого-либо типа.

Т.е. типы - это больше про данные.

**Интерфейсы** больше относятся к **действиям** над какими-либо данными, к поведению объектов, к их взаимодействию нежели к самим данным и объектам. С одной стороны, интерфейс - это "договор", который обязуется выполнить класс, _реализующий_ его. С другой стороны, интерфейс - это тип данных, потому что _...его описание достаточно чётко определяет свойства объектов, чтобы наравне с классом типизировать переменные_. и далее: _...Следует, однако, подчеркнуть, что интерфейс не является полноценным типом данных, так как он задаёт только внешнее поведение объектов. Внутреннюю структуру и реализацию заданного интерфейсом поведения обеспечивает класс, реализующий интерфейс; именно поэтому «экземпляров интерфейса» в чистом виде не бывает, и любая переменная типа «интерфейс» содержит экземпляры конкретных классов_ (источник: статья про [интерфейсы в ООП](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) в Википедии).

Т.о. для описания классов, функций и данных логичнее использовать типы. Компоненты React - это функции, даже т.н. классовые компоненты суть функции. И применять к ним термин "интерфейс" не совсем правильно, хоть эти функции и реализуют определенный контракт (например, принимают данные одного типа, а возвращают данные другого типа, выполнив ряд манипуляций).

Для использования с классами подходят одинаково и типы, и интерфейсы. Однако, если класс реализует некоторое "внешнее" поведение, которое, в теории, может быть переопределено разработчиком в классе-наследнике, то логичнее использовать интерфейсы. Т.о. разработчик дает знать, что именно экземпляр класса может делать, какие действия выполнять. Если же класс является описательным - задает некоторую структуру информации и определяет методы работы с ней, т.е. реализует некоторое "внутреннее" поведение, то логичнее использовать тип, а не интерфейс.

Есть особенности, которые существуют только в типах и невозможны в интерфейсах: псевдонимы примитивных типов, типы-объединения (union type), защитники (type guards), обобщения (generics), условные типы (conditional types) и пр. Есть штуки, которым можно сделать эквивалент в интерфейсах, но пострадает читаемость и объем кодовой базы (например, кортежи).

Также, есть случаи, когда лучше использовать именно интерфейсы. Например, расширение имеющегося типа или интерфейса.

Поэтому стоит использовать типы для описания данных и операций с ними, функций, "внутреннего" поведения. А интерфейсы - для гарантии реализации "внешнего" поведения и расширения имеющихся типов и интерфейсов.

## Типы предлагают больше возможностей

### Можно в типах, нельзя в интерфейсах

- определение псевдонима для простого типа, например, `type Name = string;` или `type NullOrUndefined = null | undefined;`;
- типы-объединения, например, `type Transport = 'Car' | 'Ship' | 'Plane';`;
- функциональные типы, например, `type AddFn = (num1: number, num2: number) => number;`;
- кортежи (можно обойти, но решение нельзя назвать кратким и читаемым);
- вывод типа: тип переменных и функций определяется на основе их использования (это уменьшает объем кода и упрощает его чтение);
- [условные типы](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html);
- защитники типов (type guards);
- [mapped types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html);
- [вспомогательные типы](https://www.typescriptlang.org/docs/handbook/utility-types.html).

### Можно в интерфейсах, нельзя в типах

- слияние объявлений

	```TypeScript
	interface Person {
		firstName: string;
	}

	interface Person {
		lastName: number;
	}

	const savior: Person = {
		firstName: 'John',
		lastName: 'Connor'
	};
	```

- можно создать класс, реализющий несколько интерфейсов, но нельзя создать класс с использованием типа-объединения.

## Прочее

**Компактность** - синтаксис псевдонима типа более компактен, что делает его в некоторых случаях удобнее - легче читать.

**Обработка конфликтов** при попытке расширить тип или интерфейс, в котором уже есть такое-же свойство.

При расширении интерфейсов, свойства с одинаковыми именами не допускаются:

```TypeScript
interface Person {
	getTitle: () => string;
}

interface Hero extends Person {
	getTitle: () => string[]; // ошибка
}
```

Псевдонимы типов обрабатывают конфликты по-другому. Если тип расширяет другой тип с тем же свойстом, он автоматически сольет свойства. В примере ниже сливается сигнатура метода и используется оператор `typeof` для сужения типа-объединения, чтобы можно было вернуть значение типобезопасным способом.

```TypeScript
type Person = {
	getTitle: (name: string) => string
};

type Hero = Person & {
	getTitle: (name: string[]) => string[]
};

const savior: Hero = {
	getTitle: (name: string | string[]) => {
		return (typeof name === 'string' ? `Ordinary ${name}` : [`Extraordinary ${name}`, `Marvelous ${name}`]) as string[] & string;
	}
}
```

Пересечение двух свойств может привести к неожиданному результату. В следующем примере свойство `name` становится `never`, т.к. оно не может быть одновременно двух типов - `string` и `number`:

```TypeScript
type Person = {
	name: string
};

type Hero = Person & {
	name: number
};

// error: Type 'string' is not assignable to type 'never'.
const savior: Hero = {name: 'John Connor'};
```

В общем: интерфейсы при обнаружении конфликтов выбрасывают ошибку, типы сливают свойства. Поэтому, если нужно перегружать функции, то стоит использовать псевдонимы типов.

## Когда использовать типы и интерфейсы

Хотя все особенности интерфейсов возможны в типах или имеют эквиваленты, исключением является слияние объявлений. В целом стоит использовать интерфейсы, когда нужно слияние объявлений, например, расширение сушествующей библиотеки. В дополнение, если отдается предпочтение объектно-ориентированному наследованию, использование ключевого слова `extends` рядом с интерфейсом является более читаемым, нежели пересечение с псевдонимом типа.

С другой стороны, многие особенности типов сложно или невозможно реализовать при помощи интерфейсов: условные типы, обобщения, защитники типов, продвинутые типы и пр. 

Во многих случаях их можно заменять друг на друга в зависимости от предпочтений. Тем не менее, стоит использовать псевдонимы типов в следующих случаях:
- создание нового имени для примитивного типа;
- определение типа-объединения, кортежа, типа функции или другого, более сложного типа;
- для перегрузки функций;
- при использовании mapped types, условных типов, защитников типов или других продвинутых особенностей типов.

В сравнении с интерфейсами типы более выразительные. Пример, когда интерфейсы не позволят сделать задуманное:

```TypeScript
type Person = {
	name: string,
	age: number
};

type Getters<T> = {
	[K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]
};

type personType = Getters<Person>;
// type clientType = {
// 	getName: () => string,
// 	getAge: () => number
// }
```

С использованием типа-отображения, шаблонных строк и оператора `keyof` в примере создается тип, который автоматически генерирует методы получения значений свойств для объектов любого типа.

Кроме того, многие разработчики предпочитают использовать типы, т.к. они хорошо соответствуют парадигме функционального программирования. Выразительность типов упрощает композицию, неизменяемость и другие возможности функционального программирования типобезопасным способом.